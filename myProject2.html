<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Blair Ednie - Data Visualization Portfolio</title>
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, sans-serif;
            line-height: 1.6;
            max-width: 800px;
            margin: 0 auto;
            padding: 20px;
            background-color: #f5f5f5;
        }
        header {
            text-align: center;
            padding: 40px 0;
            background-color: white;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            margin-bottom: 30px;
        }
        h1 {
            color: #2c3e50;
            margin: 0;
        }
        .subtitle {
            color: #7f8c8d;
            font-size: 1.2em;
            margin-top: 10px;
        }
        main {
            background-color: white;
            padding: 30px;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        p {
            color: #34495e;
        }
        .tooltip {
            position: absolute;
            background-color: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 5px;
            border-radius: 4px;
            pointer-events: none;
        }
        .viz-item {
            background: white;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        .elevation-filter {
            margin: 20px 0;
            padding: 10px;
            background-color: #f8f9fa;
            border-radius: 8px;
        }
        .elevation-filter label {
            margin-right: 10px;
        }
        .elevation-filter input {
            width: 80px;
            margin-right: 20px;
            padding: 5px;
        }
        .spaghetti-line {
            fill: none;
            stroke-width: 1;
            opacity: 0.3;
        }
        .spaghetti-line:hover {
            stroke-width: 2;
            opacity: 1;
        }
        .nav {
            text-align: center;
            margin-bottom: 20px;
        }
        .nav a {
            display: inline-block;
            padding: 10px 20px;
            background-color: #3498db;
            color: white;
            text-decoration: none;
            border-radius: 4px;
            transition: background-color 0.3s ease;
            margin: 0 10px;
        }
        .nav a:hover {
            background-color: #2980b9;
        }
    </style>
</head>
<body>
    <nav class="nav">
        <a href="index.html">Home</a>
    </nav>

    <header>
        <h1>Blair Ednie</h1>
        <div class="subtitle">Project 2: D3.js Interactive Web Page</div>
    </header>
    <main>
        <p>Project 2: D3.js Interactive Web Page</p>
        <p>These visualizations created with help from Anthropic's Claude 3.5 LLM.</p>
        
        <h2>Australian Average Max Temperature</h2>
        <p>Dataset: <a href="https://www.kaggle.com/datasets/joshmills/australian-average-daily-maximum-tempreature/data">Josh Mills's "Australian Average Daily Maximum Temperature"</a></p>
        
        <div class="viz-section">
            <h3>Single Station View</h3>
            <p><label for="station-select">Select a station:</label>
            <select id="station-select"></select></p>
            <div id="line-chart"></div>
        </div>

        <div class="viz-section">
            <h3>Temperature Comparison by Elevation</h3>
            <div class="elevation-filter">
                <h5>Filter by Elevation Range</h5>
                <label for="min-elevation">Min Elevation (m):</label>
                <input type="number" id="min-elevation" value="0">
                <label for="max-elevation">Max Elevation (m):</label>
                <input type="number" id="max-elevation" value="2000">
                <button id="update-elevation">Filter</button>
                <button id="reset-elevation">Reset</button>
            </div>
            <div id="spaghetti-plot"></div>
        </div>

        <div class="viz-section">
          <h3>Temperature vs. Elevation Relationship</h3>
          <div class="elevation-filter">
            <h5>Filter by Temperature Range</h5>
            <label for="min-temp">Min Temp (°C):</label>
            <input type="number" id="min-temp" step="0.1">
            <label for="max-temp">Max Temp (°C):</label>
            <input type="number" id="max-temp" step="0.1">
            <button id="filter-temp">Filter</button>
            <button id="reset-temp">Reset</button>
          </div>
            <div id="scatter-plot"></div>
        </div>
    </main>

    <script>
    document.addEventListener('DOMContentLoaded', function() {
        const margin = { top: 20, right: 20, bottom: 50, left: 50 };
        const width = 700 - margin.left - margin.right;
        const height = 500 - margin.top - margin.bottom;
    
        const tooltip = d3.select("body")
            .append("div")
            .attr("class", "tooltip")
            .style("opacity", 0);
    
        // Create SVGs for all plots
        const singleStationSvg = d3.select("#line-chart")
            .append("svg")
            .attr("width", width + margin.left + margin.right)
            .attr("height", height + margin.top + margin.bottom)
            .append("g")
            .attr("transform", `translate(${margin.left},${margin.top})`);
    
        const spaghettiSvg = d3.select("#spaghetti-plot")
            .append("svg")
            .attr("width", width + margin.left + margin.right)
            .attr("height", height + margin.top + margin.bottom)
            .append("g")
            .attr("transform", `translate(${margin.left},${margin.top})`);
    
        const scatterSvg = d3.select("#scatter-plot")
            .append("svg")
            .attr("width", width + margin.left + margin.right)
            .attr("height", height + margin.top + margin.bottom)
            .append("g")
            .attr("transform", `translate(${margin.left},${margin.top})`);
    
        // Create color scale for elevations
        const colorScale = d3.scaleSequential(d3.interpolateViridis);
    
        // Fetch data from GitHub URL
        d3.csv("https://raw.githubusercontent.com/bednie/cs39ae-static/refs/heads/main/AustralianAverageMaxTemp.csv").then(function(data) {
            // Parse numeric values
            data.forEach(d => {
                d.Year = +d.Year;
                d.Temp = +d.Temp;
                d.elev = +d.elev;
            });

            // Calculate elevation range for all stations once
            const stations = d3.group(data, d => d.name);
            const minElev = d3.min(Array.from(stations), ([name, values]) => values[0].elev);
            const maxElev = d3.max(Array.from(stations), ([name, values]) => values[0].elev);

            // Update colorScale domain
            colorScale.domain([minElev, maxElev]);
            
            // Set initial input values
            d3.select("#min-elevation").property("value", Math.floor(minElev));
            d3.select("#max-elevation").property("value", Math.ceil(maxElev));
    
            // Setup scales for single station plot
            const xScale = d3.scaleLinear()
                .domain(d3.extent(data, d => d.Year))
                .range([0, width]);
    
            const yScale = d3.scaleLinear()
                .domain([
                    d3.min(data, d => d.Temp) - 1,
                    d3.max(data, d => d.Temp) + 1
                ])
                .range([height, 0]);
    
            // Add axes to single station plot
            singleStationSvg.append("g")
                .attr("class", "x-axis")
                .attr("transform", `translate(0,${height})`)
                .call(d3.axisBottom(xScale).tickFormat(d3.format("d")));
    
            singleStationSvg.append("g")
                .attr("class", "y-axis")
                .call(d3.axisLeft(yScale));
    
            // Add labels to single station plot
            singleStationSvg.append("text")
                .attr("class", "x-label")
                .attr("text-anchor", "middle")
                .attr("x", width / 2)
                .attr("y", height + 40)
                .text("Year");
    
            singleStationSvg.append("text")
                .attr("class", "y-label")
                .attr("text-anchor", "middle")
                .attr("transform", `translate(${-40},${height/2}) rotate(-90)`)
                .text("Temperature (°C)");
    
            // Calculate station averages for scatter plot
            const stationAverages = Array.from(d3.group(data, d => d.name), ([name, values]) => ({
                name: name,
                elev: values[0].elev,
                avgTemp: d3.mean(values, d => d.Temp)
            }));

            // Calculate min and max temperatures
            const minTemp = d3.min(stationAverages, d => d.avgTemp);
            const maxTemp = d3.max(stationAverages, d => d.avgTemp);
            
            // Set input values
            d3.select("#min-temp").property("value", minTemp.toFixed(1));
            d3.select("#max-temp").property("value", maxTemp.toFixed(1));
            
            // Create scales for scatter plot
            const xScaleScatter = d3.scaleLinear()
                .domain([0, d3.max(data, d => d.elev)])
                .range([0, width]);
            
            const yScaleScatter = d3.scaleLinear()
                .domain([minTemp - 1, maxTemp + 1])
                .range([height, 0]);
    
            // Add axes to scatter plot
            scatterSvg.append("g")
                .attr("transform", `translate(0,${height})`)
                .call(d3.axisBottom(xScaleScatter))
                .append("text")
                .attr("x", width / 2)
                .attr("y", 40)
                .attr("fill", "black")
                .text("Elevation (m)");
    
            scatterSvg.append("g")
                .call(d3.axisLeft(yScaleScatter))
                .append("text")
                .attr("transform", "rotate(-90)")
                .attr("y", -40)
                .attr("x", -height / 2)
                .attr("text-anchor", "middle")
                .attr("fill", "black")
                .text("Average Temperature (°C)");
            
            // Create trendline
            const xMean = d3.mean(stationAverages, d => d.elev);
            const yMean = d3.mean(stationAverages, d => d.avgTemp);
            const ssxy = d3.sum(stationAverages, d => (d.elev - xMean) * (d.avgTemp - yMean));
            const ssxx = d3.sum(stationAverages, d => (d.elev - xMean) * (d.elev - xMean));
            const slope = ssxy / ssxx;
            const intercept = yMean - slope * xMean;
                
            // Add scatter points
            scatterSvg.selectAll(".point")
                .data(stationAverages)
                .enter()
                .append("circle")
                .attr("class", "point")
                .attr("cx", d => xScaleScatter(d.elev))
                .attr("cy", d => yScaleScatter(d.avgTemp))
                .attr("r", 5)
                .attr("fill", "steelblue")
                .attr("opacity", 0.7)
                .on("mouseover", (event, d) => {
                    tooltip.transition()
                        .duration(200)
                        .style("opacity", .9);
                    tooltip.html(`
                        Station: ${d.name}<br/>
                        Elevation: ${d.elev}m<br/>
                        Avg Temperature: ${d.avgTemp.toFixed(2)}°C
                    `)
                        .style("left", (event.pageX + 10) + "px")
                        .style("top", (event.pageY - 28) + "px");
                })
                .on("mouseout", () => {
                    tooltip.transition()
                        .duration(500)
                        .style("opacity", 0);
                });

            // Add the trendline
            const x1 = 0;
            const x2 = d3.max(stationAverages, d => d.elev);
            const y1 = intercept + slope * x1;
            const y2 = intercept + slope * x2;
            
            scatterSvg.append("line")
                .attr("class", "trendline")
                .attr("x1", xScaleScatter(x1))
                .attr("y1", yScaleScatter(y1))
                .attr("x2", xScaleScatter(x2))
                .attr("y2", yScaleScatter(y2))
                .attr("stroke", "red")
                .attr("stroke-width", 2)
                .attr("stroke-dasharray", "4,4");

            // Function to filter scatter plot by temperature range
            function filterByTemperature() {
              const minTemp = +d3.select("#min-temp").property("value");
              const maxTemp = +d3.select("#max-temp").property("value");
            
              scatterSvg.selectAll(".point")
                .attr("fill", d => {
                  if (d.avgTemp >= minTemp && d.avgTemp <= maxTemp) {
                    return "steelblue";
                  } else {
                    return "lightgray";
                  }
                })
                .attr("opacity", d => {
                  if (d.avgTemp >= minTemp && d.avgTemp <= maxTemp) {
                    return 0.7;
                  } else {
                    return 0.3;
                  }
                });
            
              // Update trendline visibility
              scatterSvg.select(".trendline")
                .style("opacity", minTemp || maxTemp ? 0.3 : 1);
            }
            
            // Event listener for filter button
            d3.select("#filter-temp").on("click", filterByTemperature);
            
            // Event listener for scatter plot reset button
            d3.select("#reset-temp").on("click", () => {
                // Reset input values to min/max
                d3.select("#min-temp").property("value", minTemp.toFixed(1));
                d3.select("#max-temp").property("value", maxTemp.toFixed(1));
                
                // Reset the points
                scatterSvg.selectAll(".point")
                    .attr("fill", "steelblue")
                    .attr("opacity", 0.7);
            
                // Reset trendline
                scatterSvg.select(".trendline")
                    .style("opacity", 1);
            });
    
            // Populate station dropdown
            const stations = [...new Set(data.map(d => d.name))];
            d3.select("#station-select")
                .selectAll("option")
                .data(stations)
                .enter()
                .append("option")
                .text(d => d);
    
            // Function to update single station plot
            function updateSingleStation(station) {
                const stationData = data.filter(d => d.name === station);
    
                // Update line
                const line = d3.line()
                    .x(d => xScale(d.Year))
                    .y(d => yScale(d.Temp));
    
                singleStationSvg.selectAll(".line").remove();
                singleStationSvg.selectAll(".dot").remove();
    
                singleStationSvg.append("path")
                    .datum(stationData)
                    .attr("class", "line")
                    .attr("fill", "none")
                    .attr("stroke", "steelblue")
                    .attr("stroke-width", 1.5)
                    .attr("d", line);
    
                // Add dots with tooltips
                singleStationSvg.selectAll(".dot")
                    .data(stationData)
                    .enter()
                    .append("circle")
                    .attr("class", "dot")
                    .attr("cx", d => xScale(d.Year))
                    .attr("cy", d => yScale(d.Temp))
                    .attr("r", 3)
                    .on("mouseover", (event, d) => {
                        tooltip.transition()
                            .duration(200)
                            .style("opacity", .9);
                        tooltip.html(`
                            Year: ${d.Year}<br/>
                            Temperature: ${d.Temp.toFixed(2)}°C<br/>
                            Station: ${d.name}<br/>
                            Elevation: ${d.elev}m
                        `)
                            .style("left", (event.pageX + 10) + "px")
                            .style("top", (event.pageY - 28) + "px");
                    })
                    .on("mouseout", () => {
                        tooltip.transition()
                            .duration(500)
                            .style("opacity", 0);
                    });
            }
    
            // Function to update spaghetti plot
            function updateSpaghettiPlot(minElev, maxElev) {
                const stations = d3.group(data, d => d.name);
                
                const filteredStations = Array.from(stations).filter(([name, values]) => {
                    const elevation = values[0].elev;
                    return elevation >= minElev && elevation <= maxElev;
                });
    
                const line = d3.line()
                    .x(d => xScale(d.Year))
                    .y(d => yScale(d.Temp));
    
                spaghettiSvg.selectAll(".spaghetti-line").remove();
                spaghettiSvg.selectAll(".axis").remove();
    
                spaghettiSvg.append("g")
                    .attr("class", "axis")
                    .attr("transform", `translate(0,${height})`)
                    .call(d3.axisBottom(xScale).tickFormat(d3.format("d")));
    
                spaghettiSvg.append("g")
                    .attr("class", "axis")
                    .call(d3.axisLeft(yScale));

                // Add labels to spaghetti plot
                spaghettiSvg.append("text")
                    .attr("class", "x-label")
                    .attr("text-anchor", "middle")
                    .attr("x", width / 2)
                    .attr("y", height + 40)
                    .text("Elevation (m)");
        
                spaghettiSvg.append("text")
                    .attr("class", "y-label")
                    .attr("text-anchor", "middle")
                    .attr("transform", `translate(${-40},${height/2}) rotate(-90)`)
                    .text("Temperature (°C)");
    
                filteredStations.forEach(([name, values]) => {
                    spaghettiSvg.append("path")
                        .datum(values)
                        .attr("class", "spaghetti-line")
                        .attr("d", line)
                        .style("stroke", d => colorScale(d[0].elev))
                        .on("mouseover", (event, d) => {
                            tooltip.transition()
                                .duration(200)
                                .style("opacity", .9);
                            tooltip.html(`
                                Station: ${d[0].name}<br/>
                                Elevation: ${d[0].elev}m<br/>
                                Average Temp: ${d3.mean(d, d => d.Temp).toFixed(2)}°C
                            `)
                                .style("left", (event.pageX + 10) + "px")
                                .style("top", (event.pageY - 28) + "px");
                        })
                        .on("mouseout", () => {
                            tooltip.transition()
                                .duration(500)
                                .style("opacity", 0);
                        });
                });
            }
    
            // Initial plots
            updateSingleStation(stations[0]);
            updateSpaghettiPlot(Math.floor(minElev), Math.ceil(maxElev));
    
            // Event listeners
            d3.select("#station-select").on("change", function() {
                updateSingleStation(this.value);
            });
    
            d3.select("#update-elevation").on("click", () => {
                const minElev = +d3.select("#min-elevation").property("value");
                const maxElev = +d3.select("#max-elevation").property("value");
                updateSpaghettiPlot(minElev, maxElev);
            });

            // Event listener for spaghetti plot reset button
            d3.select("#reset-elevation").on("click", () => {
                // Reset input values to min/max elevation across all stations
                d3.select("#min-elevation").property("value", Math.floor(minElev));
                d3.select("#max-elevation").property("value", Math.ceil(maxElev));
                
                // Reset the plot to show lines for all stations
                updateSpaghettiPlot(Math.floor(minElev), Math.ceil(maxElev));
            });
                        
            // Add Enter key listener to temperature filter inputs
            d3.select("#min-temp").on("keypress", function(event) {
                if (event.keyCode === 13 || event.key === "Enter") {
                    filterByTemperature();
                }
            });
            
            d3.select("#max-temp").on("keypress", function(event) {
                if (event.keyCode === 13 || event.key === "Enter") {
                    filterByTemperature();
                }
            });
            
            // Add Enter key listener to elevation filter inputs
            d3.select("#min-elevation").on("keypress", function(event) {
                if (event.keyCode === 13 || event.key === "Enter") {
                    const minElev = +d3.select("#min-elevation").property("value");
                    const maxElev = +d3.select("#max-elevation").property("value");
                    updateSpaghettiPlot(minElev, maxElev);
                }
            });
            
            d3.select("#max-elevation").on("keypress", function(event) {
                if (event.keyCode === 13 || event.key === "Enter") {
                    const minElev = +d3.select("#min-elevation").property("value");
                    const maxElev = +d3.select("#max-elevation").property("value");
                    updateSpaghettiPlot(minElev, maxElev);
                }
            });
    
        }).catch(function(error) {
            console.log(error);
            d3.selectAll(".viz-section")
                .append("p")
                .attr("class", "error")
                .text("Error loading data: " + error.message);
        });
    });
    </script>
</body>
</html>
